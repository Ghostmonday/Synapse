// Sinapse Database Schema
// Use this file with dbdiagram.io to generate visual diagrams
// Visit: https://dbdiagram.io and paste this content

Project Sinapse {
  database_type: 'PostgreSQL'
  Note: 'Sinapse Communication Platform Database Schema'
}

// Core Tables
Table users {
  id uuid [primary key, default: `gen_random_uuid()`]
  handle text [unique, not null]
  display_name text
  created_at timestamptz [not null, default: `now()`]
  is_verified boolean [default: false]
  metadata jsonb [default: `'{}'::jsonb`]
  policy_flags jsonb [default: `'{}'::jsonb`]
  last_seen timestamptz
  federation_id text [unique]
  
  Note: 'User profiles with trust metadata and federation support'
}

Table rooms {
  id uuid [primary key, default: `gen_random_uuid()`]
  slug text [unique, not null]
  title text
  created_by uuid [ref: > users.id]
  created_at timestamptz [not null, default: `now()`]
  is_public boolean [default: true]
  partition_month text [generated always as]
  metadata jsonb [default: `'{}'::jsonb`]
  fed_node_id text
  retention_hot_days int
  retention_cold_days int
  active_users int [default: 0]
  
  Note: 'Chat rooms with partition keys and retention overrides'
}

Table room_memberships {
  id uuid [primary key, default: `gen_random_uuid()`]
  room_id uuid [ref: > rooms.id, not null]
  user_id uuid [ref: > users.id, not null]
  role text [default: 'member', note: 'owner, admin, mod, member, banned']
  joined_at timestamptz [not null, default: `now()`]
  strike_count int [default: 0]
  probation_until timestamptz
  last_warning_at timestamptz
  ban_reason jsonb [default: `'{}'::jsonb`]
  
  indexes {
    (room_id, user_id) [unique]
  }
  
  Note: 'User memberships in rooms with roles and moderation tracking'
}

Table messages {
  id uuid [primary key, default: `gen_random_uuid()`]
  room_id uuid [ref: > rooms.id, not null]
  sender_id uuid [ref: > users.id]
  created_at timestamptz [not null, default: `now()`]
  payload_ref text [not null]
  content_preview text
  content_hash text [not null]
  audit_hash_chain text [not null]
  flags jsonb [default: `'{}'::jsonb`]
  is_flagged boolean [default: false]
  is_exported boolean [default: false]
  partition_month text [generated always as]
  fed_origin_hash text
  reactions jsonb [default: `'[]'::jsonb`]
  thread_id uuid [ref: > threads.id]
  reply_to uuid [ref: > messages.id]
  is_edited boolean [default: false]
  rendered_html text
  
  indexes {
    (room_id, created_at) [desc]
    content_hash
    is_flagged [where: 'is_flagged = true']
    reactions [type: gin]
    thread_id [where: 'thread_id IS NOT NULL']
    reply_to [where: 'reply_to IS NOT NULL']
  }
  
  Note: 'Message records with content references and metadata'
}

Table message_receipts {
  id uuid [primary key, default: `gen_random_uuid()`]
  message_id uuid [ref: > messages.id, not null]
  user_id uuid [ref: > users.id, not null]
  delivered_at timestamptz
  read_at timestamptz
  
  indexes {
    (message_id, user_id) [unique]
  }
  
  Note: 'Delivery and read receipts for messages'
}

// P0 Feature Tables
Table threads {
  id uuid [primary key, default: `gen_random_uuid()`]
  parent_message_id uuid [ref: > messages.id, not null]
  room_id uuid [ref: > rooms.id, not null]
  title varchar(255)
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  message_count int [default: 0]
  is_archived boolean [default: false]
  created_by uuid [ref: > users.id]
  
  indexes {
    parent_message_id
    room_id [where: 'is_archived = false']
    updated_at [desc, where: 'is_archived = false']
  }
  
  Note: 'Message threads for nested conversations'
}

Table edit_history {
  id uuid [primary key, default: `gen_random_uuid()`]
  message_id uuid [ref: > messages.id, not null]
  old_content text [not null]
  edited_by uuid [ref: > users.id, not null]
  edited_at timestamptz [default: `now()`]
  
  indexes {
    message_id
    edited_at [desc]
  }
  
  Note: 'History of message edits'
}

// Integrated Feature Tables
Table assistants {
  id uuid [primary key, default: `gen_random_uuid()`]
  owner_id uuid [ref: > users.id, not null]
  name varchar(255) [not null]
  description text
  model varchar(100) [default: 'gpt-4']
  temperature decimal(3,2) [default: 0.7]
  system_prompt text
  is_active boolean [default: true]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  metadata jsonb [default: `'{}'::jsonb`]
  
  indexes {
    owner_id
    is_active [where: 'is_active = true']
  }
  
  Note: 'AI assistant configurations'
}

Table bots {
  id uuid [primary key, default: `gen_random_uuid()`]
  name varchar(255) [not null]
  url varchar(500) [not null]
  token varchar(255) [unique, not null]
  created_by uuid [ref: > users.id, not null]
  is_active boolean [default: true]
  permissions jsonb [default: `'{}'::jsonb`]
  metadata jsonb [default: `'{}'::jsonb`]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  
  indexes {
    created_by
    token
    is_active [where: 'is_active = true']
  }
  
  Note: 'Bot registrations with webhook URLs'
}

Table bot_endpoints {
  id uuid [primary key, default: `gen_random_uuid()`]
  bot_id uuid [ref: > bots.id, not null]
  endpoint_url varchar(500) [not null]
  webhook_secret varchar(255)
  event_types text[] [default: `'{}'`]
  is_active boolean [default: true]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  
  indexes {
    bot_id
    is_active [where: 'is_active = true']
  }
  
  Note: 'Webhook endpoints for bots'
}

Table subscriptions {
  id uuid [primary key, default: `gen_random_uuid()`]
  user_id uuid [ref: > users.id, not null]
  push_sub jsonb [not null]
  endpoint varchar(500) [not null]
  p256dh varchar(255)
  auth varchar(255)
  created_at timestamptz [default: `now()`]
  updated_at timestamptz [default: `now()`]
  expires_at timestamptz
  is_active boolean [default: true]
  
  indexes {
    user_id
    is_active [where: 'is_active = true']
    endpoint
  }
  
  Note: 'Push notification subscriptions'
}

Table embeddings {
  id uuid [primary key, default: `gen_random_uuid()`]
  message_id uuid [ref: > messages.id, not null]
  vector vector(1536) [not null]
  model varchar(100) [default: 'text-embedding-3-small']
  created_at timestamptz [default: `now()`]
  
  indexes {
    message_id
    vector [type: hnsw, note: 'HNSW index for cosine similarity']
  }
  
  Note: 'Vector embeddings for semantic search'
}

Table metrics {
  id uuid [primary key, default: `gen_random_uuid()`]
  type varchar(100) [not null]
  value decimal(15,2) [not null]
  metadata jsonb [default: `'{}'::jsonb`]
  timestamp timestamptz [default: `now()`]
  
  indexes {
    type
    timestamp [desc]
    (type, timestamp) [desc]
  }
  
  Note: 'Analytics and metrics tracking'
}

Table presence_logs {
  id uuid [primary key, default: `gen_random_uuid()`]
  user_id uuid [ref: > users.id, not null]
  room_id uuid [ref: > rooms.id]
  status varchar(50) [not null, note: 'online, offline, away, busy']
  created_at timestamptz [default: `now()`]
  
  indexes {
    user_id
    room_id
    created_at [desc]
  }
  
  Note: 'User presence tracking'
}

// System Tables
Table audit_log {
  id bigserial [primary key]
  event_time timestamptz [not null, default: `now()`]
  event_type text [not null]
  room_id uuid
  user_id uuid
  message_id uuid
  payload jsonb
  actor text
  signature text
  hash text [not null]
  prev_hash text
  chain_hash text [not null]
  node_id text [default: 'local']
  
  indexes {
    (room_id, event_time) [desc]
    (node_id, id) [desc]
    event_type
  }
  
  Note: 'Append-only audit trail with chained hashes'
}

Table logs_raw {
  id uuid [primary key, default: `gen_random_uuid()`]
  room_id uuid [ref: > rooms.id, not null]
  created_at timestamptz [not null, default: `now()`]
  payload bytea [not null]
  mime_type text [not null]
  length_bytes int [not null]
  checksum text [not null]
  processed boolean [default: false]
  
  Note: 'Raw log payloads before compression'
}

Table logs_compressed {
  id uuid [primary key, default: `gen_random_uuid()`]
  room_id uuid [not null]
  partition_month text [not null]
  created_at timestamptz [not null, default: `now()`]
  codec text [not null]
  compressed_payload bytea [not null]
  original_length int [not null]
  checksum text [not null]
  cold_storage_uri text
  lifecycle_state text [default: 'hot']
  
  Note: 'Compressed logs with partitioning by partition_month'
}

Table telemetry {
  id uuid [primary key, default: `gen_random_uuid()`]
  event_time timestamptz [not null, default: `now()`]
  event text [not null]
  room_id uuid
  user_id uuid
  risk numeric
  action text
  features jsonb
  latency_ms int
  precision_recall jsonb [default: `'{}'::jsonb`]
  
  indexes {
    event_time [desc]
  }
  
  Note: 'System telemetry and metrics'
}

Table system_config {
  key text [primary key]
  value jsonb [not null]
  updated_at timestamptz [default: `now()`]
  
  Note: 'System configuration key-value store'
}

// Service Schema Tables
Table service.encode_queue {
  id uuid [primary key, default: `gen_random_uuid()`]
  raw_id uuid [ref: > logs_raw.id, not null]
  status text [not null, default: 'pending']
  attempts int [default: 0]
  max_attempts int [default: 3]
  last_attempt_at timestamptz
  error text
  created_at timestamptz [not null, default: `now()`]
  
  indexes {
    status [where: 'status = pending']
  }
  
  Note: 'Compression job queue'
}

Table service.moderation_queue {
  id uuid [primary key, default: `gen_random_uuid()`]
  message_id uuid [ref: > messages.id, not null]
  status text [not null, default: 'pending']
  attempts int [default: 0]
  max_attempts int [default: 3]
  last_attempt_at timestamptz
  error text
  created_at timestamptz [not null, default: `now()`]
  
  indexes {
    status [where: 'status = pending']
  }
  
  Note: 'Moderation job queue'
}

// Relationships
Ref: room_memberships.room_id > rooms.id [delete: cascade]
Ref: room_memberships.user_id > users.id [delete: cascade]
Ref: messages.room_id > rooms.id [delete: cascade]
Ref: messages.sender_id > users.id [delete: set null]
Ref: messages.thread_id > threads.id [delete: set null]
Ref: messages.reply_to > messages.id [delete: set null]
Ref: message_receipts.message_id > messages.id [delete: cascade]
Ref: message_receipts.user_id > users.id [delete: cascade]
Ref: threads.parent_message_id > messages.id [delete: cascade]
Ref: threads.room_id > rooms.id [delete: cascade]
Ref: threads.created_by > users.id [delete: set null]
Ref: edit_history.message_id > messages.id [delete: cascade]
Ref: edit_history.edited_by > users.id [delete: cascade]
Ref: assistants.owner_id > users.id [delete: cascade]
Ref: bots.created_by > users.id [delete: cascade]
Ref: bot_endpoints.bot_id > bots.id [delete: cascade]
Ref: subscriptions.user_id > users.id [delete: cascade]
Ref: embeddings.message_id > messages.id [delete: cascade]
Ref: presence_logs.user_id > users.id [delete: cascade]
Ref: presence_logs.room_id > rooms.id [delete: cascade]
Ref: logs_raw.room_id > rooms.id [delete: cascade]
Ref: service.encode_queue.raw_id > logs_raw.id [delete: cascade]
Ref: service.moderation_queue.message_id > messages.id [delete: cascade]

