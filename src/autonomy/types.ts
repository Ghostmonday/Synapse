/**
 * Type definitions for autonomy system
 */

/**
 * TelemetryEvent type based on Supabase schema
 * 
 * Represents a single telemetry event recorded in the database.
 * Events are generated by the system when anomalies are detected.
 */
export type TelemetryEvent = {
  id: string; // Unique event ID (UUID)
  room_id: string | null; // Associated room (if event is room-specific)
  user_id: string | null; // Associated user (if event is user-specific)
  event_time: string; // ISO timestamp when event occurred
  event: 'message_stall' | 'chat_deadlock' | 'spam_burst' | string; // Event type
  risk: number | null; // Risk score (0.0 to 1.0, where 1.0 = highest risk)
  action: string | null; // Action taken (if any) in response to event
  features: Record<string, unknown> | null; // Additional event metadata (JSONB)
  latency_ms: number | null; // Latency measurement in milliseconds (for stall events)
  precision_recall: Record<string, unknown> | null; // ML model metrics (if applicable)
};

/**
 * Prediction output from LLM reasoner
 * 
 * Structure returned by LLMReasoner.predict() method.
 * All fields validated by Zod schema before use.
 */
export type PredictionOutput = {
  failures: string[]; // List of detected failure descriptions
  recommendations: string; // Human-readable recommendation text
  reasoning?: string; // LLM's explanation of the problem
  proposedActions?: string[]; // Actionable commands/scripts to execute
};

/**
 * Predicts potential failures from telemetry events (simple rule-based method)
 * 
 * This is a fallback/simple predictor that doesn't require LLM.
 * Used for quick failure detection before LLM analysis.
 * 
 * Rules:
 * - message_stall: Latency > 5000ms (5 seconds)
 * - chat_deadlock: Any deadlock event
 * - spam_burst: Risk score > 0.7 (70% confidence)
 * 
 * @param events - Array of telemetry events to analyze
 * @returns Array of predicted failure strings (human-readable descriptions)
 */
export function predictFailures(events: TelemetryEvent[]): string[] {
  const failures: string[] = [];
  
  // Iterate through events and apply rule-based detection
  for (const event of events) {
    // Message stall: High latency indicates messages are delayed
    // Threshold: 5000ms (5 seconds) - configurable based on SLA
    if (event.event === 'message_stall' && event.latency_ms && event.latency_ms > 5000) {
      failures.push(`Message stall detected in room ${event.room_id} with latency ${event.latency_ms}ms`);
    }
    
    // Chat deadlock: System is stuck (no messages processing)
    // Any deadlock event is a failure (no threshold needed)
    if (event.event === 'chat_deadlock') {
      failures.push(`Chat deadlock detected in room ${event.room_id}`);
    }
    
    // Spam burst: High risk score indicates likely spam/attack
    // Threshold: 0.7 (70% confidence) - balances false positives vs detection
    if (event.event === 'spam_burst' && event.risk && event.risk > 0.7) {
      failures.push(`Spam burst detected in room ${event.room_id} with risk ${event.risk}`);
    }
  }
  
  return failures;
}

